Крапивин Андрей
Это доработанный скрипт https://drive.google.com/file/d/0By-zQ6shEKllM0x2ZWQ1OEhMdXc/view?usp=sharing12
Поправил расчет. Добавил детализацию до процедур/функций. Самое главное - формирует файл ccm.xml для плагина https://wiki.jenkins-ci.org/display/JENKINS/CCM+Plugin3 чтобы красиво выводить статистику(по аналогии с дублированием кода)
Строка запуска oscript ./tools/cyclo.os ./src/ ccm.xml ccm.txt




// Обработка предназначена для автоматизированного расчета цикломатической сложности кода
// Адрес публикации на Инфорстарте: http://infostart.ru/public/166182/
// Вы можете использовать обработку по своему усмотрению в рамках действующего законодательства.
// Единственная просьба: если у вас есть замечания или предложения по улучшению обработки, а также в случае нахождения багов - пишите мне об этом на http://infostart.ru/profile/101097/

#Использовать cmdline
#Использовать logos
#Использовать strings

Перем МассивСтрокМодуля Экспорт;
Перем ДеревоРезультатовАнализа;
Перем ТекстМодуля;
Перем Лог;

// функция ищет следующее, после указанного символа, вхождение подстроки
//
// Параметры
//  Строка  – Строка – строка, в которой нужно искать
//  Подстрока  – Строка – строка, которую нужно найти
//	НачинатьС - Число - номер символа, с которого нужно начинать поиск
//				(если не указан, начинает с начала)
//
// Возвращаемое значение:
//   Число   – номер символа, с которого начинается (очередное) вхождения подстроки в строку
//
Функция НайтиСледующееВхождениеПодстроки(Знач Строка, Знач Подстрока, НачинатьС = 1) Экспорт
	Результат = Найти(Сред(ВРег(Строка), НачинатьС), ВРег(Подстрока));
	Если Результат <> 0 Тогда
		Результат = Результат + НачинатьС - 1;
	КонецЕсли;

	Возврат Результат;
КонецФункции

// функция ищет предыдущее, перед указанным символом, вхождение подстроки
//
// Параметры
//  Строка  – Строка – строка, в которой нужно искать
//  Подстрока  – Строка – строка, которую нужно найти
//	НачинатьС - Число - номер символа, с которого нужно начинать поиск
//			(если не указан, начинает с конца)
//
// Возвращаемое значение:
//   Число   – номер символа, с которого начинается (предыдущее) вхождения подстроки в строку
//
Функция НайтиПредыдущееВхождениеПодстроки(Знач Строка, Знач Подстрока, Знач НачинатьС = 0) Экспорт
	Строка = ВРег(Строка);
	Подстрока = ВРег(Подстрока);

	ДлинаСтроки = СтрДлина(Строка);
	ДлинаПодстроки = СтрДлина(Подстрока);
	Если НачинатьС = 0 Тогда
		НачинатьС = ДлинаСтроки - ДлинаПодстроки + 1;
	КонецЕсли;

	Результат = 0;

	Пока НачинатьС > 0 И Результат = 0 Цикл
		// сравнивать напрямую нельзя - строки могут быть в разных регистрах
		Если Найти(Сред(Строка, НачинатьС, ДлинаПодстроки), Подстрока) = 1 Тогда
			// нашли вхождение подстроки
			Результат = НачинатьС;
		КонецЕсли;
		НачинатьС = НачинатьС - 1;
	КонецЦикла;

	Возврат Результат;
КонецФункции

// процедура выполняет удаление всех двойных кавычек в модуле
//
// Параметры
//  Текст  – Строка – текст анализируемого модуля
//
Процедура УбратьДвойныеКавычки(Текст) Экспорт
	Текст = СтрЗаменить(Текст, """""", "");
КонецПроцедуры

// процедура выполняет удаление всех комментариев модуля
//
// Параметры
//  Текст  – Строка – текст анализируемого модуля
//
Процедура УбратьКомментарии(Текст) Экспорт
	ПозицияНачалаКомментария = НайтиСледующееВхождениеПодстроки(Текст, "//");
	Пока ПозицияНачалаКомментария <> 0 Цикл
		//перед тем, как удалять нужно проверить, что эти слеши не находятся в строке
		НачалоТекущейСтроки = НайтиПредыдущееВхождениеПодстроки(Текст, Символы.ПС, ПозицияНачалаКомментария);
		Если НачалоТекущейСтроки = 0 Тогда
			НачалоТекущейСтроки = 1;
		КонецЕсли;

		ТекущаяСтрока = СокрЛ(Сред(Текст, НачалоТекущейСтроки, ПозицияНачалаКомментария - НачалоТекущейСтроки));
		КоличествоКавычек = СтрЧислоВхождений(ТекущаяСтрока, """");
		Если Лев(ТекущаяСтрока, 1) = "|" Тогда
			КоличествоКавычек = КоличествоКавычек + 1;
		КонецЕсли;

		Если КоличествоКавычек % 2 = 1 Тогда
			// найденные слэши находятся внутри строковой константы - это НЕ начало комментария, их можно просто удалить
			Текст = Лев(Текст, ПозицияНачалаКомментария - 1) + Сред(Текст, ПозицияНачалаКомментария + 2);
		Иначе
			// это начало комментария, текст после них до конца строки можно удалить
			НачалоСледующейСтроки = НайтиСледующееВхождениеПодстроки(Текст, Символы.ПС, ПозицияНачалаКомментария);
			Текст = Лев(Текст, ПозицияНачалаКомментария - 1) + ?(НачалоСледующейСтроки <> 0, Сред(Текст, НачалоСледующейСтроки), "");
		КонецЕсли;

		ПозицияНачалаКомментария = НайтиСледующееВхождениеПодстроки(Текст, "//");
	КонецЦикла;
КонецПроцедуры

// функция выполняет удаление всех строковых констант модуля
//
// Параметры
//  Текст  – Строка – текст анализируемого модуля
//
// Возвращаемое значение:
//   Число   – код возникшей ошибки:
//			1 - нечетное количество кавычек
//
Функция УбратьСтроковыеКонстанты(Текст) Экспорт
	Результат = 0;

	КоличествоКавычек = СтрЧислоВхождений(Текст, """");

	Если КоличествоКавычек % 2 = 1 Тогда
		Возврат 1;
	КонецЕсли;

	ПозицияНачалаСтроковойКонстанты = 1;
	Пока ПозицияНачалаСтроковойКонстанты <> 0 Цикл
		ПозицияНачалаСтроковойКонстанты = НайтиСледующееВхождениеПодстроки(Текст, """");
		ПозицияОкончанияСтроковойКонстанты = НайтиСледующееВхождениеПодстроки(Текст, """", ПозицияНачалаСтроковойКонстанты + 1);

		Текст = Лев(Текст, ПозицияНачалаСтроковойКонстанты - 1) + Сред(Текст, ПозицияОкончанияСтроковойКонстанты + 1);
	КонецЦикла;

	Возврат Результат;
КонецФункции

// процедура выполняет удаление всех комментариев модуля
//
// Параметры
//  Текст  – Строка – текст анализируемого модуля
//	Директива - Строка - идентификатор директивы (# или &)
//
Процедура УбратьДирективыКомпиляции(Текст, Директива) Экспорт
	ПозицияНачалаДирективы = НайтиСледующееВхождениеПодстроки(Текст, Директива);
	Пока ПозицияНачалаДирективы <> 0 Цикл
		НачалоТекущейСтроки = НайтиПредыдущееВхождениеПодстроки(Текст, Символы.ПС, ПозицияНачалаДирективы);
		Если НачалоТекущейСтроки = 0 Тогда
			НачалоТекущейСтроки = 1;
		КонецЕсли;

		СтрокаПередХешем = Сред(Текст, НачалоТекущейСтроки, ПозицияНачалаДирективы - НачалоТекущейСтроки);

		// директивы не могут стоять после других команд или текста в строке - перед ними могут быть только незначащие символы
		Если СокрЛП(СтрокаПередХешем) = "" Тогда
			НачалоСледующейСтроки = НайтиСледующееВхождениеПодстроки(Текст, Символы.ПС, ПозицияНачалаДирективы + 1);
			Если НачалоСледующейСтроки = 0 Тогда
				НачалоСледующейСтроки = СтрДлина(Текст);
			КонецЕсли;
			Текст = ?(НачалоТекущейСтроки > 1, Лев(Текст, НачалоТекущейСтроки), "") + Сред(Текст, НачалоСледующейСтроки);
		КонецЕсли;

		ПозицияНачалаДирективы = НайтиСледующееВхождениеПодстроки(Текст, Директива, ПозицияНачалаДирективы);
	КонецЦикла;
КонецПроцедуры

// функция выделяет из переданного текста текст следующего метода и возвращает его
//
// Параметры
//  Текст  – Строка – текст анализируемого модуля
//	ИмяМетода - Строка - функция возвращает имя найденного метода
//	НачалоБлока - Число - с какой строки начинается анализируемый блок
//	КонецБлока - Число - какой строкой заканчивается
//
// Возвращаемое значение:
//   Строка – текст очередного метода
//
Функция ИзвлечьСледующийМетод(Текст, ИмяМетода, ЭтоФункция, НачалоБлока, КонецБлока)
	Результат = "";
	ИмяМетода = "";
	КонецМетода = 0;

	// анализируем следующий метод
	ПозицияСкобки = НайтиСледующееВхождениеПодстроки(Текст, "(");
	Если ПозицияСкобки <> 0 Тогда
		ЗаголовокМетода = Лев(Текст, ПозицияСкобки - 1);
		НачалоБлока = НачалоБлока + СтрЧислоВхождений(ЗаголовокМетода, Символы.ПС);
		ЗаголовокМетода = СокрЛП(ЗаголовокМетода);
		Текст = Сред(Текст, ПозицияСкобки);

		Если ВРег(Лев(ЗаголовокМетода, 9)) = ВРег("Процедура") ИЛИ
			 ВРег(Лев(ЗаголовокМетода, 9)) = ВРег("Procedure") Тогда

			 ЭтоФункция = Ложь;	
			ИмяМетода = СокрЛП(Сред(ЗаголовокМетода, 11));
			КонецМетодаРусс = НайтиСледующееВхождениеПодстроки(Текст, "КонецПроцедуры");
			КонецМетодаАнгл = НайтиСледующееВхождениеПодстроки(Текст, "EndProcedure");
			Если КонецМетодаРусс <> 0 Тогда
				Если КонецМетодаАнгл <> 0 Тогда
					Если КонецМетодаРусс < КонецМетодаАнгл Тогда
						КонецМетода = КонецМетодаРусс + 14; // 14 = СтрДлина("КонецПроцедуры")
					Иначе
						КонецМетода = КонецМетодаАнгл + 12; // 12 = СтрДлина("EndProcedure")
					КонецЕсли;
				Иначе
					КонецМетода = КонецМетодаРусс + 14; // 14 = СтрДлина("КонецПроцедуры")
				КонецЕсли;
			Иначе // КонецМетодаРусс = 0
				Если КонецМетодаАнгл <> 0 Тогда
					КонецМетода = КонецМетодаАнгл + 12; // 12 = СтрДлина("EndProcedure")
				Иначе
					ВызватьИсключение "Не удалось найти завершение процедуры " + ИмяМетода;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ВРег(Лев(ЗаголовокМетода, 7)) = ВРег("Функция") ИЛИ
			 	  ВРег(Лев(ЗаголовокМетода, 8)) = ВРег("Function") Тогда
			ЭтоФункция = Истина;
			Если ВРег(Лев(ЗаголовокМетода, 7)) = ВРег("Функция") Тогда
				ИмяМетода = СокрЛП(Сред(ЗаголовокМетода, 8));
			Иначе
				ИмяМетода = СокрЛП(Сред(ЗаголовокМетода, 9));
			КонецЕсли;

			КонецМетодаРусс = НайтиСледующееВхождениеПодстроки(Текст, "КонецФункции");
			КонецМетодаАнгл = НайтиСледующееВхождениеПодстроки(Текст, "EndFunction");
			Если КонецМетодаРусс <> 0 Тогда
				Если КонецМетодаАнгл <> 0 Тогда
					Если КонецМетодаРусс < КонецМетодаАнгл Тогда
						КонецМетода = КонецМетодаРусс + 12; // 12 = СтрДлина("КонецФункции")
					Иначе
						КонецМетода = КонецМетодаАнгл + 11; // 11 = СтрДлина("EndFunction")
					КонецЕсли;
				Иначе
					КонецМетода = КонецМетодаРусс + 12; // 12 = СтрДлина("КонецФункции")
				КонецЕсли;
			Иначе // КонецМетодаРусс = 0
				ЭтоФункция = Ложь;
				Если КонецМетодаАнгл <> 0 Тогда
					КонецМетода = КонецМетодаАнгл + 11; // 11 = СтрДлина("EndFunction")
				Иначе
					ВызватьИсключение "Не удалось найти завершение функции " + ИмяМетода;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Если КонецМетода <> 0 Тогда
		Результат = СокрЛП(Лев(Текст, КонецМетода));
		КонецБлока = НачалоБлока + СтрЧислоВхождений(Результат, Символы.ПС); 
		Текст = Сред(Текст, КонецМетода + 1);
	Иначе
		ИмяМетода = "<Инициализация модуля>";
		КонецБлока = НачалоБлока + СтрЧислоВхождений(Текст, Символы.ПС); 
		Результат = СокрЛП(Текст);
		Текст = "";
	КонецЕсли;

	Возврат Результат;
КонецФункции

// функция ищет следующее вхождение Слова в Текст
//
// Параметры
//  Текст  – Строка – анализируемый текст
//  Слово  – Строка – искомое слово
//	НачинатьС - Число - откуда искать
//
// Возвращаемое значение:
//   Число   – начало следующего вхождения слова
//
Функция НайтиСледующееВхождениеСлова(Текст, Слово, Знач Курсор = 1)
	СловоНайдено = Ложь;
	ДлинаСлова = СтрДлина(Слово);
	Пока Курсор <> 0 И Не СловоНайдено Цикл
		Курсор =  НайтиСледующееВхождениеПодстроки(Текст, Слово, Курсор);
		//проверим, что это не часть идентификатора
		Если Курсор <> 0 Тогда
			КодСимволаСлева = КодСимвола(Текст, Курсор - 1);
			КодСимволаСправа = КодСимвола(Текст, Курсор + ДлинаСлова);
			Если НЕ (
				(КодСимволаСлева >= 97 И КодСимволаСлева <= 122) ИЛИ		// a-z
				(КодСимволаСлева >= 65 И КодСимволаСлева <= 90) ИЛИ			// A-Z
				(КодСимволаСлева >= 1040 И КодСимволаСлева <= 1103) ИЛИ		// А-Я,а-я
				(КодСимволаСлева >= 48 И КодСимволаСлева <= 57) ИЛИ			// 0-9
				(КодСимволаСлева = 95) ИЛИ	// "_"
				(КодСимволаСправа >= 97 И КодСимволаСправа <= 122) ИЛИ		// a-z
				(КодСимволаСправа >= 65 И КодСимволаСправа <= 90) ИЛИ		// A-Z
				(КодСимволаСправа >= 1040 И КодСимволаСправа <= 1103) ИЛИ	// А-Я,а-я
				(КодСимволаСправа >= 48 И КодСимволаСправа <= 57) ИЛИ		// 0-9
				(КодСимволаСправа = 95)	 // "_"
				) Тогда // это не часть идентификатора
				СловоНайдено = Истина;
			Иначе
				Курсор = Курсор + ДлинаСлова;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	Возврат Курсор;
КонецФункции

// процедура вычисляет цикломатическую сложность переданного текста и записывает результаты анализа в узел дерева
//
// Параметры
//  Текст  – Строка – текст анализируемого модуля
//
Процедура ВычислитьЦикломатическуюСложность(Знач Текст, УзелДереваРезультатов) Экспорт
	УбратьДвойныеКавычки(Текст);
	УбратьКомментарии(Текст);
	Если УбратьСтроковыеКонстанты(Текст) = 1 Тогда
		// ошибка при разборе
		УзелДереваРезультатов.ИмяМетода = "Нечетное количество кавычек в модуле. Анализ не произведен!";
		Возврат;
	КонецЕсли;
	УбратьДирективыКомпиляции(Текст, "#");
	УбратьДирективыКомпиляции(Текст, "&");

	// убираем объявление переменных
	НачалоПервогоМетода = СтрДлина(Текст);
	Курсор = НайтиСледующееВхождениеПодстроки(Текст, "Процедура");
	НачалоПервогоМетода = Мин(НачалоПервогоМетода, ?(Курсор = 0, НачалоПервогоМетода, Курсор));
	Курсор = НайтиСледующееВхождениеПодстроки(Текст, "Procedure");
	НачалоПервогоМетода = Мин(НачалоПервогоМетода, ?(Курсор = 0, НачалоПервогоМетода, Курсор));
	Курсор = НайтиСледующееВхождениеПодстроки(Текст, "Функция");
	НачалоПервогоМетода = Мин(НачалоПервогоМетода, ?(Курсор = 0, НачалоПервогоМетода, Курсор));
	Курсор = НайтиСледующееВхождениеПодстроки(Текст, "Function");
	НачалоПервогоМетода = Мин(НачалоПервогоМетода, ?(Курсор = 0, НачалоПервогоМетода, Курсор));
	Если НачалоПервогоМетода <> СтрДлина(Текст) Тогда
		Остаток = Лев(Текст, НачалоПервогоМетода-1);
		Текст = Сред(Текст, НачалоПервогоМетода);
	КонецЕсли;
	НачалоМетода = СтрЧислоВхождений(Остаток, Символы.ПС)+1;
	КонецМетода = 0;
	МаксимальнаяСложностьУзлов = 0;
	Пока Текст <> "" Цикл
		//ОбработкаПрерыванияПользователя();
		ИмяМетода = "";
		ЭтоФункция = Ложь;
		Попытка
			ТекстМетода = ИзвлечьСледующийМетод(Текст, ИмяМетода, ЭтоФункция, НачалоМетода, КонецМетода);

			ЦикломатическаяСложность =
				1 + СтрЧислоВхождений(ТекстМетода, "Тогда")
				+ СтрЧислоВхождений(ТекстМетода, "Then")
				+ СтрЧислоВхождений(ТекстМетода, "Цикл")
				+ СтрЧислоВхождений(ТекстМетода, "Do")
				+ СтрЧислоВхождений(ТекстМетода, "Попытка")
				+ СтрЧислоВхождений(ТекстМетода, "Try")
				+ СтрЧислоВхождений(ТекстМетода, "Возврат") - ?(ЭтоФункция, 1, 0)
				+ СтрЧислоВхождений(ТекстМетода, "Return") - ?(ЭтоФункция, 1, 0)
				+ СтрЧислоВхождений(ТекстМетода, "ВызватьИсключение")
				+ СтрЧислоВхождений(ТекстМетода, "Raise")
				+ СтрЧислоВхождений(ТекстМетода, "Продолжить")
				+ СтрЧислоВхождений(ТекстМетода, "Continue")
				+ СтрЧислоВхождений(ТекстМетода, "Прервать")
				+ СтрЧислоВхождений(ТекстМетода, "Break")
				+ ?(Истина, СтрЧислоВхождений(ТекстМетода, "?"), 0);
			ТекущаяСтрока = УзелДереваРезультатов.Строки.Добавить();
			ТекущаяСтрока.Файл = УзелДереваРезультатов.Файл;
			ТекущаяСтрока.Путь = УзелДереваРезультатов.Путь;
			ТекущаяСтрока.ИмяМетода = ИмяМетода;
			ТекущаяСтрока.ЦикломатическаяСложность = ЦикломатическаяСложность;
			ТекущаяСтрока.НачалоБлока = НачалоМетода;
			ТекущаяСтрока.КонецБлока  = КонецМетода;
			ТекущаяСтрока.Смещение = КонецМетода-НачалоМетода;
			МаксимальнаяСложностьУзлов = Макс(МаксимальнаяСложностьУзлов, ЦикломатическаяСложность);
			НачалоМетода = КонецМетода+1;
		Исключение
			ТекущаяСтрока = УзелДереваРезультатов.Строки.Добавить();
			ТекущаяСтрока.Файл = УзелДереваРезультатов.Файл;
			ТекущаяСтрока.ИмяМетода = "Не удалось обработать модуль: " + ИмяМетода;
			ТекущаяСтрока.НачалоБлока = НачалоМетода;
			ТекущаяСтрока.КонецБлока  = КонецМетода;
			ТекущаяСтрока.Смещение = КонецМетода-НачалоМетода;
			ТекущаяСтрока.ЦикломатическаяСложность = 0;
			НачалоМетода = КонецМетода;
		КонецПопытки;
	КонецЦикла;
	УзелДереваРезультатов.ЦикломатическаяСложность = МаксимальнаяСложностьУзлов;
КонецПроцедуры

// процедура расчитывает цикломатическую сложность реквизита ТекстМодуля
//
Процедура ВычислитьСложностьТекстаМодуля(Узел, ТекстМодуля) Экспорт
	Лог.Информация("Анализ текста модуля...");
	ТекущийУзел = Узел.Строки.Добавить();
	ТекущийУзел.Файл = Узел.Файл;
	ТекущийУзел.Путь = Узел.Путь;
	ВычислитьЦикломатическуюСложность(ТекстМодуля, ТекущийУзел);
КонецПроцедуры

// процедура расчитывает цикломатическую сложность модулей файлов каталога
//
// Параметры
//  ПутьКаталога  – Строка – путь к анализируемому каталогу
//  МаскаФайлов   – Строка – маска для поиска файлов в каталоге
//
Процедура ВычислитьСложностьМодулейВКаталоге(ПутьКаталога, МаскаФайлов = "", ВключатьПодкаталоги = Ложь) Экспорт
	Если Не ЗначениеЗаполнено(ПутьКаталога) Тогда
		Возврат;
	КонецЕсли;

	Лог.Информация("Поиск файлов...");
	ТекущийФайл = Новый Файл(ПутьКаталога);

	Если ТекущийФайл.ЭтоКаталог() Тогда
		МассивФайлов = НайтиФайлы(ПутьКаталога, ?(ЗначениеЗаполнено(МаскаФайлов), МаскаФайлов, "*"), ВключатьПодкаталоги);
	Иначе
		МассивФайлов =  Новый Массив;
		МассивФайлов.Добавить(ТекущийФайл);
	КонецЕсли;

	Если МассивФайлов.Количество() = 0 Тогда
		Лог.Информация("Подходящий файлов не найдено!");
		Возврат;
	КонецЕсли;

	ДеревоРезультатовАнализа.Строки.Очистить();
	ТекстовыйФайл = Новый ТекстовыйДокумент;
	Для каждого ТекущийФайл Из МассивФайлов Цикл
		Лог.Информация("Анализ файла " + ТекущийФайл.ПолноеИмя + "...");

		Если ТекущийФайл.ЭтоФайл() Тогда
			ТекущийУзел = ДеревоРезультатовАнализа.Строки.Добавить();
			ТекущийУзел.Файл = ТекущийФайл.Имя;
			ТекущийУзел.Путь = ТекущийФайл.Путь;
			ТекстовыйФайл.Прочитать(ТекущийФайл.ПолноеИмя);
			ТекстМодуля = ТекстовыйФайл.ПолучитьТекст();
			ВычислитьСложностьТекстаМодуля(ТекущийУзел, ТекстМодуля);
		КонецЕсли;
	КонецЦикла;
	ТекстовыйФайл = Неопределено;

	Лог.Информация("Анализ завершен!");
КонецПроцедуры

Функция ОпределитьУровеньПроблемы(ЦикломатическаяСложность)
	Если Число(ЦикломатическаяСложность)>=15 Тогда
		Возврат "F";
	ИначеЕсли Число(ЦикломатическаяСложность)>=10 Тогда
		Возврат "D"
	ИначеЕсли Число(ЦикломатическаяСложность)>=5 Тогда
		Возврат "C"
	ИначеЕсли Число(ЦикломатическаяСложность)>1 Тогда
		Возврат "B";
	Иначе
		Возврат "A";
	КонецЕсли;
КонецФункции

Процедура СформироватьФайлОтчетаCCM(ПутьКФайлу) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ПутьКФайлу,"UTF-8",Ложь);
	ЗаписьXML.ЗаписатьНачалоЭлемента("ccm");
	Для Каждого ОбъектАнализа из ДеревоРезультатовАнализа.Строки Цикл
		Для Каждого Модуль из ОбъектАнализа.Строки Цикл
			Для Каждого ПроцФунк Из Модуль.Строки Цикл
				Если ПроцФунк.ЦикломатическаяСложность = 1 Тогда Продолжить КонецЕсли;
				ЗаписьXML.ЗаписатьНачалоЭлемента("metric");
					ЗаписьXML.ЗаписатьНачалоЭлемента("complexity");
						ЗаписьXML.ЗаписатьТекст(строка(ПроцФунк.ЦикломатическаяСложность));
					ЗаписьXML.ЗаписатьКонецЭлемента();
					ЗаписьXML.ЗаписатьНачалоЭлемента("unit");
						ЗаписьXML.ЗаписатьТекст(ПроцФунк.ИмяМетода);
					ЗаписьXML.ЗаписатьКонецЭлемента();
					ЗаписьXML.ЗаписатьНачалоЭлемента("classification");
						ЗаписьXML.ЗаписатьТекст(ОпределитьУровеньПроблемы(ПроцФунк.ЦикломатическаяСложность));
					ЗаписьXML.ЗаписатьКонецЭлемента();
					ЗаписьXML.ЗаписатьНачалоЭлемента("file");
						ЗаписьXML.ЗаписатьТекст(ПроцФунк.Путь+ПроцФунк.Файл);
					ЗаписьXML.ЗаписатьКонецЭлемента();
					ЗаписьXML.ЗаписатьНачалоЭлемента("startLineNumber");
						ЗаписьXML.ЗаписатьТекст(ПроцФунк.НачалоБлока);
					ЗаписьXML.ЗаписатьКонецЭлемента();
					ЗаписьXML.ЗаписатьНачалоЭлемента("endLineNumber");
						ЗаписьXML.ЗаписатьТекст(ПроцФунк.КонецБлока);
					ЗаписьXML.ЗаписатьКонецЭлемента();
				ЗаписьXML.ЗаписатьКонецЭлемента();
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.Закрыть();

	//Дополнительные преобразования
	Чтение = Новый ЧтениеТекста(ПутьКФайлу, "utf-8");
	Текст = Чтение.Прочитать();
	Чтение.Закрыть();
	Запись = Новый ТекстовыйДокумент;
	Запись.УстановитьТекст(Текст);
	Запись.Записать(ПутьКФайлу, "utf-8", Символы.ПС);
КонецПроцедуры

Процедура СформироватьФайлОтчетаCheckStyle(ПутьКФайлу)
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.ОткрытьФайл(ПутьКФайлу,"UTF-8",Ложь);
	ЗаписьXML.ЗаписатьНачалоЭлемента("checkstyle");
	Для Каждого ОбъектАнализа из ДеревоРезультатовАнализа.Строки Цикл
		Для Каждого Модуль из ОбъектАнализа.Строки Цикл
			ЗаписьXML.ЗаписатьНачалоЭлемента("file");
				ЗаписьXML.ЗаписатьАтрибут("name", Модуль.Путь+Модуль.Файл);
				Для Каждого ПроцФунк Из Модуль.Строки Цикл
					Если ПроцФунк.ЦикломатическаяСложность>10 Тогда
						ЗаписьXML.ЗаписатьНачалоЭлемента("error");
							ЗаписьXML.ЗаписатьАтрибут("line", ПроцФунк.НачалоБлока);
							ЗаписьXML.ЗаписатьАтрибут("severity", "error");
							ЗаписьXML.ЗаписатьАтрибут("message", "Сложность "+ПроцФунк.ЦикломатическаяСложность+". Допустимая 10");
							ЗаписьXML.ЗаписатьАтрибут("source", "Здравый смысл");
						ЗаписьXML.ЗаписатьКонецЭлемента();
					ИначеЕсли ПроцФунк.ЦикломатическаяСложность>5 Тогда
						ЗаписьXML.ЗаписатьНачалоЭлемента("error");
							ЗаписьXML.ЗаписатьАтрибут("line", ПроцФунк.НачалоБлока);
							ЗаписьXML.ЗаписатьАтрибут("severity", "waring");
							ЗаписьXML.ЗаписатьАтрибут("message", "Сложность "+ПроцФунк.ЦикломатическаяСложность+". Допустимая 10");
							ЗаписьXML.ЗаписатьАтрибут("source", "Здравый смысл");
						ЗаписьXML.ЗаписатьКонецЭлемента();
					КонецЕсли
				КонецЦикла;
			ЗаписьXML.ЗаписатьКонецЭлемента();
		КонецЦикла;
	КонецЦикла;
	ЗаписьXML.ЗаписатьКонецЭлемента();
	ЗаписьXML.Закрыть();

	//Дополнительные преобразования
	Чтение = Новый ЧтениеТекста(ПутьКФайлу, "utf-8");
	Текст = Чтение.Прочитать();
	Чтение.Закрыть();
	Запись = Новый ТекстовыйДокумент;
	Запись.УстановитьТекст(Текст);
	Запись.Записать(ПутьКФайлу, "utf-8", Символы.ПС);

	ОБ_ДД=Новый ДвоичныеДанные(ПутьКФайлу);
    Стр_Base64=Base64Строка(ОБ_ДД);
    ОБ_ДД=Base64Значение(Сред(Стр_Base64,5));
    ОБ_ДД.Записать(ПутьКФайлу);

КонецПроцедуры

Парсер = Новый ПарсерАргументовКоманднойСтроки();
Парсер.ДобавитьПараметр("ПутьКИсходникам");
Парсер.ДобавитьПараметр("ПутьКОтчетуCCM");
Парсер.ДобавитьПараметр("ПутьКОтчетуCheckstyle");
Парсер.ДобавитьПараметр("ПутьКЛогу");
Параметры = Парсер.Разобрать(АргументыКоманднойСтроки);

Лог = Логирование.ПолучитьЛог("oscript.app.cyclo");
Аппендер = Новый ВыводЛогаВФайл();
Аппендер.ОткрытьФайл(Параметры["ПутьКЛогу"]);
Лог.ДобавитьСпособВывода(Аппендер);

ВыводПоУмолчанию = Новый ВыводЛогаВКонсоль();
Лог.ДобавитьСпособВывода(ВыводПоУмолчанию);

Лог.Информация("Расчет цикломатической сложности");

ДеревоРезультатовАнализа = Новый ДеревоЗначений;
ДеревоРезультатовАнализа.Колонки.Добавить("Путь");
ДеревоРезультатовАнализа.Колонки.Добавить("Файл");
ДеревоРезультатовАнализа.Колонки.Добавить("ИмяМетода");
ДеревоРезультатовАнализа.Колонки.Добавить("ЦикломатическаяСложность");
ДеревоРезультатовАнализа.Колонки.Добавить("НачалоБлока");
ДеревоРезультатовАнализа.Колонки.Добавить("КонецБлока");
ДеревоРезультатовАнализа.Колонки.Добавить("Смещение");

ВычислитьСложностьМодулейВКаталоге(Параметры["ПутьКИсходникам"],"*.bsl",Истина);

СформироватьФайлОтчетаCCM(Параметры["ПутьКОтчетуCCM"]);
СформироватьФайлОтчетаCheckStyle(Параметры["ПутьКОтчетуCheckstyle"]);

СуммаЦикломатикиПоОбъектам = 0;

Сч=0;
Для каждого _строкаДерева из ДеревоРезультатовАнализа.Строки Цикл
	Для каждого _строкаМодуля из _строкаДерева.Строки Цикл
		СуммаЦикломатикиПоОбъектам = СуммаЦикломатикиПоОбъектам + _строкаМодуля.ЦикломатическаяСложность;
		Лог.Информация(" Файл " +  _строкаМодуля.Путь + _строкаМодуля.Файл + " cyclo - " + _строкаМодуля.ЦикломатическаяСложность) ;
		Сч=Сч+1;
	КонецЦикла;
КонецЦикла;

Лог.Информация("Средняя цикломатическая сложность " + СуммаЦикломатикиПоОбъектам/Сч);